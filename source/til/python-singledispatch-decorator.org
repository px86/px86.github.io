#+TITLE: Python singledispatch decorator
#+SUBTITLE: transform a function into a generic single-dispatcher
#+AUTHOR: Pushkar Raj
#+EMAIL: px86@protonmail.com
#+DATE: [2023-05-03 Wed]

Today, I came to know about the =singledispatch= decorator from the =functools= module. It transforms a function into a generic single dispatch function. The function then dispatches to other functions,  based on the type of its first argument.

It will be clearer with examples.

#+begin_src python
  from functools import singledispatch

  @singledispatch
  def foo(arg):
      """Default implementation."""
      print(f"This is the default implementation: {arg}")
#+end_src

#+RESULTS:

Now we can /register/ specific implementations of =foo= based on type of =arg=.

#+begin_src python
  @foo.register
  def _(arg: int):
      """Implementation of foo for int type."""
      twice = 2 * arg
      print(f"twice of {arg} is {twice}.")

  # notice how arg type can also be passed inside @foo.register(...)
  @foo.register(str)
  def _(arg):
      """Implementation of foo for str type."""
      print(f"length of '{arg}' is {len(arg)}.")


  foo(10)     # Output: twice of 10 is 20.
  foo("abc")  # Output: length of 'abc' is 3.
  foo(None)   # Output: This is the default implementation: None
#+end_src

 =register= returns the undecorated function, so it is possible to stack multiple /register/ decorations on top of each-other.

#+begin_src python
  class Pet:
      pass

  class Cat(Pet):
      pass

  class Dog(Pet):
      pass

  class Snake(Pet):
      pass

  @foo.register(Pet)
  def _(arg):
      print("Not Implemented")

  # decorator stacking, because register returns the undecorated function
  @foo.register(Dog)
  @foo.register(Cat)
  def _(arg):
      print(f"Cool...")

  # lambdas, or predefined functions can be registered in this way
  foo.register(Snake, lambda arg: print("Not cool.."))
#+end_src


To check which function will be called for a given type, we can use the =dispatch= attribute. /This would have been more useful if we had named our functions differently/. ðŸ˜…

#+begin_src python
  foo.dispatch(int)  # <function _ at 0x7ff8f3c07f70>
  foo.dispatch(str)  # <function _ at 0x7ff8f3c21040>
#+end_src

The =registry= attribute will return all the registered types and their corresponding functions.

Also, we can use =singledispatchmethod= on class methods to convert them into a generic single dispatchers. It will dispatch based on the first /non-self/, or /non-cls/ argument.


*RESOURCE*: https://docs.python.org/3/library/functools.html
